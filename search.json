[{"title":"破解linux版sublime text 3176","url":"/2018/05/14/crackSublime3176/","content":"\n- 我是基于apt安装的sublime text 3176，在命令行中输入下面的命令即可（原则上debian系的所有发行版均可，其他请自行测试）\n\n***\n### 操作过程\n\n- 先在hosts中添加``0.0.0.0 license.sublimehq.com``, 这是防止证书被移走\n\n- 然后新建脚本，保存为crack_sublime.sh\n\n`` \n#!/bin/bash\n\nSUBLIME_EXECUTABLE=\"$1\"\nCRACK=\"$2\"\n\nOFFSET_1=$((\"$(binwalk -R '\\x41\\x56\\x53\\x48\\x83\\xEC\\x70\\x49\\x89\\xFE\\x48\\x8D\\x7C\\x24\\x48' $SUBLIME_EXECUTABLE | tail -n2 | awk '{ print $2 }')\" - 1))\nOFFSET_2=$((\"$(binwalk -R '\\x48\\x89\\xFB\\x80\\x3B\\x00\\x74\\x22\\x48\\x8D\\x7B' $SUBLIME_EXECUTABLE | tail -n2 | awk '{ print $2 }')\" - 1))\nOFFSET_3=$((\"$(binwalk -R '\\x22\\x00\\x55\\x41\\x57\\x41\\x56\\x41\\x55\\x41\\x54' $SUBLIME_EXECUTABLE | tail -n2 | awk '{ print $2 }')\" + 2))\n\nprintf \"OFFSET_1=0x%04x\\n\" \"$OFFSET_1\"\nprintf \"OFFSET_2=0x%04x\\n\" \"$OFFSET_2\"\nprintf \"OFFSET_3=0x%04x\\n\" \"$OFFSET_3\"\n\nif [[ $CRACK == 'true' ]]; then\n    printf '\\xC3' | dd seek=$((\"$OFFSET_1\")) conv=notrunc bs=1 of=\"$SUBLIME_EXECUTABLE\"\n    printf '\\xC3' | dd seek=$((\"$OFFSET_2\")) conv=notrunc bs=1 of=\"$SUBLIME_EXECUTABLE\"\n    printf \"\\x48\\xc7\\xc0\\x01\\x00\\x00\\x00\\xc3\" | dd seek=$((\"$OFFSET_3\")) conv=notrunc bs=1 of=\"$SUBLIME_EXECUTABLE\"\nfi\n\n`` \n\n - 到脚本目录运行\n`` sudo bash ./crack_sublime.sh /opt/sublime_text/sublime_text true ``\n\n### 效果图\n\n![效果图](http://ww1.sinaimg.cn/mw690/6ace449bgy1fraprms8yij208x054t8r.jpg)","tags":["crack"]},{"title":"神经网络学习","url":"/2018/02/08/神经网络学习/","content":"\n\n\n - &emsp;&emsp;最近几个月一直在看NLP相关的资料，各种算法什么的（基本上看不懂），还好网上一堆大大有做好的工具，还顺带训练好了模型。尝试了大量的分词工具，逐渐明白一些简单的道理，其实好多东西都不要太多数理知识就可以用，本来程序的实现也是为了这么一个目标吧大概。但是初次接触tensorflow和pytorch等工具还是有种回到单片机时代一样，每踩一步都认真查资料。也因此感觉对于代码的理解和操控有了更强一点的概念。\n\n\n### MorvanZhou的教程\n****\n - 可以说这是我最近最大的一个发现了，能用浅显易懂的中文进行深度学习的开课，还是全免费的。目前还只是看了pytorch的几个初级教程，虽然没有说十分理解，但是也在我脑子里有了挺大的一块进展。\n \n - 怎么就说是很大的进展呢，之前一直都没搞懂隐藏层(Hidden Layer)的意义，以及反向传递(backward)有什么意义，昨天看了几遍简单的课程，竟然理解了，比知乎上抛知识，甩公式的解说好太多，因此，强烈安利一波。\n \n - [莫烦老师的系列教程地址][1]\n \n \n \n ### 知识记录\n ****\n \n - **隐藏层**：所谓隐藏层就是除了输入和输出以外的中间层，作用就是拿来作为神经元的容器，一般一层就够了，神经元数量的设计更为重要。\n \n - **神经元**：所谓的神经元也很好理解，就是拿来感知数据的单元，等于每个单元控制一片线性区域，围在一起就是一整个隐藏层。\n \n - **反向传递**：反向传递其实就是一个通过比较训练值和真实值之间产生的误差，自动进行校正操作的过程，神经网络之所以能自主学习也是因为这样。\n \n - **激活函数**：激活函数目的是为了让数据更加线性化，还有可以控制数值的区域，可以说是一种魔法操作。\n \n \n \n [1]: https://morvanzhou.github.io\n","tags":["深度学习"]},{"title":"关于最近对于框架的一些思考","url":"/2017/05/05/关于最近对于框架的一些思考/","content":"\n最近做招聘网站，用 tp3。其实前两周就想写个文章记录一下自己最近学习到的东西，不过被人民的名义拦住了我记录的步伐。趁着项目刚刚完结的间隙，做点小记录。\n\n##1. 对代码分层的思考\n\n因为代码编写的功底一直都是自学，基本上也没什么框架架构的思想在里面。用了 tp 看见很多人都说写坏习惯，毕竟一个 M 方法就可以快速调用数据库里对应的表还生成对应的 CURD 方法，真的挺便捷的。所以完全可以一个 controller 就把一整个模块实现。但是一直做着一个招聘网站，不自觉间慢慢地也理解并学会了一些框架里的强大便捷之处。\n\n代码全都耦合到控制器中自己过一段时间会很慌，所以目前就做了简单的分层，搞了一层 model(虽然本来就应该这么做)。经历了一段坏习惯以后，忽然明白了模型的重要性和便捷之处。首先一般的框架都有自动验证和自动完成数据接收的方法，需要在模型里进行简单的定义。另一个层面就是级联操作，“级联” 一词是在做毕业前的实训接触到的，一个词的理解真的需要好长时间才能明白真真的意义。为了级联操作，可以实现一个完整的关联删除功能；也为了视图模型，视图模型其实就是带有一堆 join 语句的模型，自己来实现这样的功能好麻烦，框架预处理一套方案，只需要自己定义一下即可。\n\n因为 tp 里没有什么路由的概念，只有一个 rewrite 的方案，跟最新的框架设计有一定区别，因此还需要 logic 层和 service 层；model 默认就是 curd 和接收返回数据，业务逻辑丢给 logic，服务类方法塞进 service（类似于当前模型的工具包）。\n\n结构清晰明了了以后就明白其实控制器就是个路由，还有一些基本上接近无逻辑的调用操作。M 层承担了大部分的逻辑和细分功能的编写，整体就清晰了，无论项目多么庞大都可以很快地找准目的地。也提高了可读性和可理解性。\n\n##2. 对代码注释的思考\n\n因为一直都是一堆 function 的堆积写法，所以一向都有注释的习惯，可是我的注释更偏向于逻辑步骤的注释，一方面方便自己的开发思路，另一方面别人要改代码的话也好理解。无注释真的是考验理解能力到爆炸的程度。\n\n此外还因为用了注释插件，可以很方便地写方法的注释，标记方法的用途，和使用方法已经返回的数据。还有 git 提交也应该写上精炼简洁的内容，方便别人一眼看出你提交的代码是些什么东西，还有 git 提交尽量一块归好一块地提交，免得代码混合在一起影响 review 检查。还有数据库的字段也应该做好对应的字段介绍，comment 里可以写上，model 里也可以再记录一下。这样就清晰明了了。\n\n##3.curl 这个坑的试验\n\n公司里的接口明明贼快，但是放到线上服务器就各种卡顿，相应缓慢对 php 程序造成的影响是巨大的，因为 php 是脚本语言，还没跑完卡住了可能会导致用户快速关闭了页面造成数据的写入不完整造成一整个账号的逻辑不关联。一不小心就蝴蝶效应，搞了好久一开始以为是服务器质量问题，后来查了一圈发现应该是 dns 的问题，具体应该说是 ip 解析跨运营商造成的问题。最快的解决方案就是写个 hosts，指定 ip，瞬间就 ok 了。\n\n上面就是最近两个月最深刻的体会，可能还是蛮落后的思想，但是感觉自己心中开始有了一点点架构的思想，是个好的新开端，end。","tags":["生活"]},{"title":"2月玩物记--极路由3","url":"/2017/03/03/2月玩物记-极路由3/","content":"\n\n买东西始终还是性价比加消费能力的权衡，不吹不黑，我用斐讯完全是为了拿个免费硬件顺便套现京东白条。然而这个路由的功能也只是放在我房间做个信号中转 + 不费力气高速翻墙。但是作为一个路由的稳定信号和稳定的的服务能力完全是欠缺的。适逢宿舍的 20M 宽带续费变 50M，我感觉路主路由器那个小玩意快要受不了这宽带了，所以下单买了个开学季降价（实际上也不值原价）的极路由 3。\n\n为什么不买极路由 4 呢，一个是太贵，一个是既然那么贵为什么不上个网件呢？网件的性价比更高，而且各种 rom。说到底还是穷，所以买了个 200 块钱以下 100 以上的路由器。\n\n首先把路由器当做一台小的 linux 主机对待，我们看看参数。cpu 都差不多那个货色不对比了。\n\n极路由3\n内存：DDR2，128MB\n闪存：16MB eMMc5.0\nGeeTurbo 2.0\n\n小米路由器3\n闪存：128MB SLC Nand Flash\n内存：128MB DDR2\n\n斐讯K2\n内存：64MB\n闪存：8MB\n好了，硬件上来看极路由容量太小，还比小米贵了一大截。\n![图片1](http://ww3.sinaimg.cn/large/0060lm7Tgy1fd9z6r2sotj30ri0oajx2.jpg)\n![图片2](http://ww2.sinaimg.cn/large/0060lm7Tgy1fd9z6r9bzqj30re0guq51.jpg)\n\n\n\n极路由都是 3 年保修 + 1 年配件保修的。小米依旧售后缩水。还有一个就是信号的频段，极路由 3 的频段覆盖非常广配合那个信号增强配件，基本上可以做到对房子全面信号覆盖。我把 5G 作为物联网的基础，2.4G 作为信号覆盖的基础，配合旧的主路由器放在最遥远的主人房间，实现信号最大化覆盖。\n\n因为网线只拉到门口，所以，我的翻墙路由器 K2 是部署在我房间，作为中间枢纽，同时方便我自己的翻墙速度。这样大家都可以保障速度和翻墙的体验。\n\n至于为什么不在主路由这个极路由 3 上跑 ss+adbyby 嘛，主要是不想丢了保修，另外装第三方 rom 就影响到了信号的覆盖，极路由既然主要优化的是信号，那我自己当然是要对信号的质量进行最高的品质控制。也就是我对极路由的性价比的体现点。1. 保修 2. 信号（说信号不好的赶紧保修就好）\n\n下面是我的出租屋的一个路由器布局\n![图片3](http://ww1.sinaimg.cn/large/6ace449bgy1fda1fdik3wj20qr0fsq4q.jpg)\n\n\nA 点作为 wifi 信号七点，经过 C 点中转实现全屋 2.4G 的覆盖，D 点连接 A 点释放的 5G 信号。B 点连接 A 点并放出 2.4G+5G 的翻墙信号。\n其他手机电脑设备自由连接，主要两个 3 个热点。2.4G 的极路由和 5G 的极路由还有 2.4G 的 K2 用于翻墙。信号和速度的搭配。","tags":["玩物"]},{"title":"微信卡券功能的玩坏教程","url":"/2016/12/23/微信卡券功能的玩坏教程/","content":"\n关于微信的卡券功能, 百度上我只能搜到的都是跟官网差不多的东西. 所以就自己对着官方文档跑了一天, 为了满足公司的需求鼓捣得到一些小心得. 情景是我们需要一堆已知 code 的卡券, 但是微信公众号后台可视化界面并不支持这样的模式. 微信自带生成的卡券是有人触发就随机分配一个码, 并不实用, 因为我们并是那种消费的业务逻辑, 而是更像是体验卡的形式.\n\n##1. 用 api 建立的卡券才能使用自定义 code 功能, 也就是譬如我想卡券用英文句子来作为卡券的码. 这种时候我们就需要调用微信公众号的 api 了, 可以使用 http://mp.weixin.qq.com/debug/ 里的测试接口生成. 也可以自己跑微信接口.\n\n敲黑板! 敲黑板! 敲黑板!\n\n麻烦的地方是不这个接口怎么触发, 而是这个卡券的 json 信息. 一大串, 关键的功能挺多的, 我都看了一天文档才搞清楚了一些.\n\n```\n{\n    \"card_type\":\"GENERAL_COUPON\",//这里有5个选择,具体是根据类型决定的\n    \"general_coupon\":{\n        \"base_info\":{/*[必填,详情看这里][1]*/},\n        \"default_detail\":'一些描述',\n        \"advanced_info\":{/*选填*/}\n    }\n}\n```\n\n只要 json 正确就能 post 过去就能看见创建了一个卡券了.\n\n##2. 本文主要是介绍自定义 code 群发这个功能, 所以必须声明的两个属性. 下面为官方原文提示\n\n如果开发者打算新创建一张支持导入 code 模式的卡券，不同于以往的创建方式，建议开发者采用以下流程创建预存 code 模式卡券，否则会报错。\n\n* 步骤一：创建预存模式卡券，将库存 quantity 初始值设置为 0，并填入 get_custom_code_mode 字段；\n* 步骤二：待卡券通过审核后，调用导入 code 接口并核查 code；\n* 步骤三：调用修改库存接口，须令卡券库存小于或等于导入 code 的数目。（为了避免混乱建议设置为相等）\n\n\n\n##3. 导入 code, 前期工作做好了, 就可以进入最关键的阶段, 一就是生成你自己需要的 code, 这个跟微信 api 无关, 你想生成什么就生成. 之后才是真的关键的地方, 卡券 code 的导入一次调用只能 100 个, 然后卡券的库存可以修改.\n\n我是一次过插入 10000 个的, 毕竟一个卡券的最高上限是 1 亿个 code. 通过 for 循环 100 个 100 个那样插入, 并且 100 个 100 个库存那样增加. 可以在后台可视化地看见 code 的数目的增长.\n![pic](http://ww4.sinaimg.cn/large/6ace449bjw1fb0t2kr8xrj20f00qomyd.jpg)\n\n总结:: 这样创建出来的卡券不能生成二维码入口, 但是可以插入到推送中, 也可以插入到服务号的菜单中.\n\n附件:\n\n```<?php\nif (isset($_GET['act'])) {\n    $act = $_GET['act'];\n}\nif(isset($_GET['tool'])){\n    $tool = $_GET['tool'];\n}\n\nif ($act == 'card_create') {\n    ;\n}elseif($act == 'check_code'){\n    $code_arr = get_code();\n    foreach ($code_arr as $key => $hundred_code) {\n        card_manager('codeCheck',0,$hundred_code);\n    }\n}elseif($act == 'import_code') {\n    $code_arr = get_code();\n    foreach ($code_arr as $key => $hundred_code) {\n        card_manager('codeDeposit',0,$hundred_code);\n        card_manager('stockModify',100);\n    }\n}elseif($act == 'card_detail'){\n    card_manager('cardGet');\n}elseif($tool == 'shorten'){\n    card_manager('long2short');\n}elseif($tool == 'gcode'){\n    generate_code();\n}elseif($tool == 'compare'){\n    compare_code_diff(\"cpyhq1.txt\",\"cpyhq2.txt\");\n}else{\n    echo \"有毛病\";\n}\n\n\nfunction get_card_id()\n{\n    $card_id = \"卡券id\";\n    return $card_id;\n}\n\nfunction card_manager($event,$stockNum=0,$code_arr=[],$stock_status='increase')\n{\n    $access_token = 'access_token还没写获取方法';\n\n    $longlink = \"\";//长链接\n\n    switch ($event) {\n        case 'codeDeposit':\n            //code储存\n            $url = \"http://api.weixin.qq.com/card/code/deposit?access_token=\".$access_token;\n            $json = json_encode(array(\"card_id\"=>get_card_id(),\"code\"=>$code_arr));\n            break;\n        case 'codeCheck':\n            //code状态检查\n            $url = \"http://api.weixin.qq.com/card/code/checkcode?access_token=\".$access_token;\n            $json = json_encode(array(\"card_id\"=>get_card_id(),\"code\"=>$code_arr));\n            break;\n        case 'stockModify':\n            //库存数量修改\n            $url = \"https://api.weixin.qq.com/card/modifystock?access_token=\".$access_token;\n            if ($stock_status=='increase') {\n                $str = \"increase_stock_value\";\n            }elseif($stock_status=='reduce'){\n                $str = \"reduce_stock_value\";\n            }\n            $json = '{\n                        \"card_id\": \"'.get_card_id().'\",\n                        \"'.$str.'\": '.$stockNum.'\n                    }';\n            break;\n        case 'cardGet':\n            //优惠卡详细信息\n            $url = \"https://api.weixin.qq.com/card/get?access_token=\".$access_token;\n            $json = json_encode(array(\"card_id\"=>get_card_id()));\n            break;\n        case 'long2short':\n            //微信短链\n            $url = \"https://api.weixin.qq.com/cgi-bin/shorturl?access_token=\".$access_token;\n            $json = json_encode(array(\"action\"=>\"long2short\",\"long_url\"=>$longlink));\n            break;\n        case 'cardUpdateName':\n            //优惠卡基本修改修改\n            $url = \"https://api.weixin.qq.com/card/update?access_token=\".$access_token;\n            $json = '{\n                       \"card_id\":\"'.get_card_id().'\",\n                       \"general_coupon\": { \n                               \"base_info\": {\n                                       \"title\":\"测评优惠券1\"\n                               }\n                       }\n                }';\n            break;\n        case 'cardDelete':\n            //优惠卡删除\n            $url = \"https://api.weixin.qq.com/card/delete?access_token=\".$access_token;\n            $json = json_encode(array(\"card_id\"=>get_card_id()));\n        default:\n            # code...\n            break;\n    }\n\n    $result = https_request($url, $json);\n    echo $result;\n}\n\nfunction generate_code(){\n    /*每两个数字之间重复的概率为90万*90万分之一\n        基本不会重复\n     */\n    $arr = array();\n    for ($i=0; $i < 10000; $i++) { \n        $a = rand(100000,999999);\n        $b = rand(100000,999999);\n        $arr[$i] = $a*$b;\n        if (strlen($arr[$i])<12) {\n            $fix = rand(0,9);\n            $arr[$i] = (string)$arr[$i].(string)$fix;\n            $arr[$i] = intval($arr[$i]);\n        }\n    }\n    if (count($arr) != count(array_unique($arr))) {   \n        generate_code();  \n    } \n    $fp = fopen('output.txt','w+');\n    foreach ($arr as $key => $value) {\n        fwrite($fp,$value.\"\\n\");\n    }\n    fclose($fp);\n    //return $arr;\n}\n\nfunction get_code(){\n    $file = 'coupon.txt';\n    $content = file_get_contents($file); //读取文件中的内容\n    $str = str_replace(array(\"\\r\\n\", \"\\r\", \"\\n\"), \" \", $content); \n    $arr = explode(' ', $str);\n    unset($arr[count($arr)-1]);\n    //把过长的code段成几截\n    $num = count($arr);\n    $return_arr = [];\n    $counter = $num%100 == 0? ($num/100)-1:floor($num/100);//分组计数器\n    for ($i=0; $i <= $counter; $i++) { \n        $return_arr[$i] = array_slice($arr,$i*100,100);\n    }\n    return $return_arr;\n}\n\nfunction compare_code_diff($f1,$f2){\n    $file1 = $f1;\n    $file2 = $f2;\n    $content = file_get_contents($file1); //读取文件中的内容\n    $str1 = str_replace(array(\"\\r\\n\", \"\\r\", \"\\n\"), \" \", $content); \n    $arr1 = explode(' ', $str1);\n\n    $content = file_get_contents($file2); //读取文件中的内容\n    $str2 = str_replace(array(\"\\r\\n\", \"\\r\", \"\\n\"), \" \", $content); \n    $arr2 = explode(' ', $str2);\n\n    print_r(array_flip(array_merge($arr1,$arr2)));\n}\n\nfunction https_request($url, $data = null)\n{\n    $curl = curl_init();\n    curl_setopt($curl, CURLOPT_URL, $url);\n    curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, FALSE);\n    curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, FALSE);\n    if (!empty($data)){\n        curl_setopt($curl, CURLOPT_POST, 1);\n        curl_setopt($curl, CURLOPT_POSTFIELDS, $data);\n    }\n    curl_setopt($curl, CURLOPT_RETURNTRANSFER, 1);\n    $output = curl_exec($curl);\n    curl_close($curl);\n    return $output;\n}\n?>\n```"}]